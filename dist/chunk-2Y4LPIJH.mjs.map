{"version":3,"sources":["../src/react/context/chipi-provider.tsx","../src/core/lib/encryption.ts","../src/core/create-wallet.ts","../src/react/hooks/use-create-wallet.ts","../src/react/hooks/use-sign.ts"],"names":[],"mappings":"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","file":"chunk-2Y4LPIJH.mjs","sourcesContent":["import { createContext, useContext } from 'react';\nimport type { ChipiSDKConfig } from '../../core/types';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\ninterface ChipiContextValue {\n  config: ChipiSDKConfig;\n}\n\nconst ChipiContext = createContext<ChipiContextValue | null>(null);\nconst queryClient = new QueryClient();\n\nexport function ChipiProvider({ \n  children, \n  config \n}: { \n  children: React.ReactNode;\n  config: ChipiSDKConfig;\n}) {\n  return (\n    <ChipiContext.Provider value={{ config }}>\n      <QueryClientProvider client={queryClient}>\n        {children}\n      </QueryClientProvider>\n    </ChipiContext.Provider>\n  );\n}\n\nexport function useChipiContext() {\n  const context = useContext(ChipiContext);\n  if (!context) {\n    throw new Error('useChipiContext must be used within a ChipiProvider');\n  }\n  return context;\n}","import CryptoJS from \"crypto-js\";\n\nexport const encryptPrivateKey = (\n  privateKey: string,\n  password: string,\n): string => {\n  if (!privateKey || !password) {\n    throw new Error(\"Private key and password are required\");\n  }\n\n  return CryptoJS.AES.encrypt(privateKey, password).toString();\n};\n\nexport const decryptPrivateKey = (\n  encryptedPrivateKey: string,\n  password: string,\n): string | null => {\n  if (!encryptedPrivateKey || !password) {\n    console.error(\"Encrypted private key and password are required\");\n    return null;\n  }\n\n  try {\n    const bytes = CryptoJS.AES.decrypt(encryptedPrivateKey, password);\n    const decrypted = bytes.toString(CryptoJS.enc.Utf8);\n\n    // Check if the decrypted string is empty\n    if (!decrypted) {\n      return null;\n    }\n\n    return decrypted;\n  } catch (error) {\n    console.error(\"Decryption failed:\", error);\n    return null;\n  }\n};\n","import type { DeploymentData, GaslessOptions } from \"@avnu/gasless-sdk\";\nimport {\n  BASE_URL,\n  fetchBuildTypedData,\n  fetchExecuteTransaction,\n} from \"@avnu/gasless-sdk\";\nimport type { Call } from \"starknet\";\nimport {\n  Account,\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CallData,\n  ec,\n  hash,\n  num,\n  RpcProvider,\n  stark,\n} from \"starknet\";\nimport { encryptPrivateKey } from \"./lib/encryption\";\nimport { WalletData } from \"./types\";\n\nexport interface CreateWalletParams {\n  encryptKey: string;\n}\n\nexport interface CreateWalletResponse {\n  success: boolean;\n  wallet: WalletData;\n  txHash: string;\n}\n\nconst NEXT_PUBLIC_ARGENT_CLASSHASH =\n  \"0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f\";\n\nconst NEXT_PUBLIC_CONTRACT_ADDRESS =\n  \"0x05039371eb9f5725bb3012934b8821ff3eb3b48cbdee3a29f798c17e9a641544\";\nconst NEXT_PUBLIC_CONTRACT_ENTRY_POINT_GET_COUNTER = \"get_counter\";\n\nexport const createArgentWallet = async (\n  params: CreateWalletParams\n): Promise<CreateWalletResponse> => {\n  try {\n    const { encryptKey } = params;\n\n    const rpcUrl = \"https://rpc.ankr.com/starknet\";\n    const options: GaslessOptions = {\n      baseUrl: \"https://starknet.api.avnu.fi\",\n      apiKey: \"98564df8-122b-4708-a2d2-ea6c93b85d46\",\n    };\n    const provider = new RpcProvider({\n      nodeUrl: rpcUrl,\n    });\n\n    // Generating the private key with Stark Curve\n    const privateKeyAX = stark.randomAddress();\n    const starkKeyPubAX = ec.starkCurve.getStarkKey(privateKeyAX);\n\n    // Using Argent X Account v0.4.0 class hash\n    // POR REVISAR: CLASSHASH ES EL MISMO EN MAINNET?\n    const accountClassHash = NEXT_PUBLIC_ARGENT_CLASSHASH;\n\n    // Calculate future address of the ArgentX account\n    const axSigner = new CairoCustomEnum({\n      Starknet: { pubkey: starkKeyPubAX },\n    });\n    // Set the dApp Guardian address\n    const axGuardian = new CairoOption<unknown>(CairoOptionVariant.None);\n\n    const AXConstructorCallData = CallData.compile({\n      owner: axSigner,\n      guardian: axGuardian,\n    });\n\n    const contractAddress = hash.calculateContractAddressFromHash(\n      starkKeyPubAX,\n      accountClassHash,\n      AXConstructorCallData,\n      0\n    );\n\n    // Initiating Account\n    const account = new Account(provider, contractAddress, privateKeyAX);\n    console.log(\"Account \", { ...account });\n\n    // Ping to activate the account\n    const initialValue: Call[] = [\n      {\n        contractAddress: NEXT_PUBLIC_CONTRACT_ADDRESS,\n        entrypoint: NEXT_PUBLIC_CONTRACT_ENTRY_POINT_GET_COUNTER,\n        calldata: [contractAddress],\n      },\n    ];\n\n    const typeData = await fetchBuildTypedData(\n      contractAddress,\n      initialValue,\n      undefined,\n      undefined,\n      { baseUrl: BASE_URL, apiKey: options.apiKey },\n      accountClassHash\n    );\n\n    const userSignature = await account.signMessage(typeData);\n\n    const deploymentData: DeploymentData = {\n      class_hash: accountClassHash,\n      salt: starkKeyPubAX,\n      unique: `${num.toHex(0)}`,\n      calldata: AXConstructorCallData.map((value) => num.toHex(value)),\n    };\n\n    const executeTransaction = await fetchExecuteTransaction(\n      contractAddress,\n      JSON.stringify(typeData),\n      userSignature,\n      options,\n      deploymentData\n    );\n\n    const encryptedPrivateKey = encryptPrivateKey(privateKeyAX, encryptKey);\n    console.log(\"Encrypted private key: \", encryptedPrivateKey);\n\n    // TODO: Guardar la wallet en dashboard\n    console.log(\n      \"Wallet created successfully with txHash: \",\n      executeTransaction.transactionHash\n    );\n    console.log(\"Account address: \", contractAddress);\n    return {\n      success: true,\n      wallet: {\n        publicKey: contractAddress,\n        encryptedPrivateKey,\n      },\n      txHash: executeTransaction.transactionHash,\n    };\n  } catch (error: unknown) {\n    console.error(\"Error detallado:\", error);\n\n    if (error instanceof Error && error.message.includes(\"SSL\")) {\n      throw new Error(\n        \"Error de conexiÃ³n SSL. Intenta usando NODE_TLS_REJECT_UNAUTHORIZED=0 o verifica la URL del RPC\"\n      );\n    }\n\n    throw new Error(\n      `Error creating Argent wallet: ${\n        error instanceof Error ? error.message : \"Unknown error\"\n      }`\n    );\n  }\n};\n","import { useMutation } from '@tanstack/react-query';\nimport { createArgentWallet, CreateWalletParams, CreateWalletResponse } from '../../core/create-wallet';\n\ninterface UseCreateWalletOptions {\n  onSuccess?: (createWalletResponse: CreateWalletResponse) => void;\n  onError?: (error: Error) => void;\n}\n\n\nexport function useCreateWallet(options?: UseCreateWalletOptions) {\n  const mutation = useMutation<CreateWalletResponse, Error, CreateWalletParams>({\n    mutationFn: createArgentWallet,\n    onSuccess: options?.onSuccess,\n    onError: options?.onError,\n  });\n\n  return {\n    createWallet: mutation.mutate,\n    createWalletAsync: mutation.mutateAsync,\n    isCreating: mutation.isPending,\n    error: mutation.error,\n    wallet: mutation.data,\n  };\n}","// import { useMutation } from '@tanstack/react-query';\n// import { executePaymasterTransaction } from '../../core/send-transaction-with-paymaster';\n// import type { SignParams,WalletData } from '../../core/types';\n\n// interface UseSignOptions {\n//   wallet: WalletData;\n//   onSuccess?: (txHash: string) => void;\n//   onError?: (error: Error) => void;\n// }\n\n// export function useSign({ wallet, ...options }: UseSignOptions) {\n//   const mutation = useMutation({\n//     mutationFn: async (params: SignParams) => {\n//       return executePaymasterTransaction({\n//         ...params,\n//         wallet,\n//         // ... other params from SDK context\n//       });\n//     },\n//     onSuccess: options?.onSuccess,\n//     onError: options?.onError,\n//   });\n\n//   return {\n//     sign: mutation.mutate,\n//     isSigning: mutation.isPending,\n//     error: mutation.error,\n//     lastTxHash: mutation.data,\n//   };\n// }\n\n\nexport function useSign(){\n  return {\n    sign: () => {\n      return \"sign 3\";\n    }\n  }\n}"]}